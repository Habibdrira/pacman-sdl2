#include <stdio.h>
#include <stdlib.h>
#include <SDL2/SDL.h>
#include <SDL2/SDL_ttf.h>
#include <math.h>

#define SCREEN_WIDTH 600
#define SCREEN_HEIGHT 400
#define ROWS 20
#define COLS 30
#define PACMAN_SPEED 20
#define GHOST_SPEED 1
#define NUM_DESTINATIONS 3

typedef struct {
    int x, y;
    int prevX, prevY;
    int lives;
    int score;
    int direction;
} Pacman;

typedef struct {
    int x, y;
    int vx, vy;
} Ghost;

SDL_Window* window = NULL;
SDL_Renderer* renderer = NULL;
TTF_Font* font = NULL;

char maze[ROWS][COLS] = {
    "#############################",
    "#..............##...........#",
    "#.#####.#####.....###.####..#",
    "#...........................#",
    "#.#####.#####...##.###.....##",
    "#...........................#",
    "#.###...##....##.........####",
    "#.......##....##...#........#",
    "###.....##....##...#........#",
    "#.......########...###......#",
    "#.##....##....##...........##",
    "#.###...##....##......##....#",
    "#.................###.......#",
    "#.###...###.....#.....###...#",
    "#...........................#",
    "#.###...###.....###......####",
    "#............#..............#",
    "#############################"
};

// Function to initialize the maze points
void initializeMazePoints() {
    for (int i = 0; i < ROWS; ++i) {
        for (int j = 0; j < COLS; ++j) {
            if (maze[i][j] == '.') {
                maze[i][j] = 'o';  // 'o' represents a point
            }
        }
    }
}

// Function to update the score and remove points when Pac-Man collects them
void collectPoints(Pacman* pacman, int x, int y) {
    int gridX = x / 20;
    int gridY = y / 20;

    if (maze[gridY][gridX] == 'o') {
        pacman->score += 5;  // Increase the score by 5 when Pac-Man collects a point
        maze[gridY][gridX] = ' ';  // Remove the point from the maze
    }
}

void initializeSDL() {
    if (SDL_Init(SDL_INIT_VIDEO) < 0) {
        fprintf(stderr, "Erreur lors de l'initialisation de SDL : %s\n", SDL_GetError());
        exit(1);
    }

    if (TTF_Init() < 0) {
        fprintf(stderr, "Erreur lors de l'initialisation de TTF : %s\n", TTF_GetError());
        exit(1);
    }

    window = SDL_CreateWindow("Pac-Man", SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED, SCREEN_WIDTH, SCREEN_HEIGHT, SDL_WINDOW_SHOWN);

    if (window == NULL) {
        fprintf(stderr, "Erreur lors de la création de la fenêtre : %s\n", SDL_GetError());
        exit(1);
    }

    renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED);

    if (renderer == NULL) {
        fprintf(stderr, "Erreur lors de la création du rendu : %s\n", SDL_GetError());
        exit(1);
    }

    font = TTF_OpenFont("arial.ttf", 24);  // Adjust the font size as needed

    if (font == NULL) {
        fprintf(stderr, "Erreur lors du chargement de la police : %s\n", TTF_GetError());
        exit(1);
    }
}

void closeSDL() {
    TTF_CloseFont(font);
    SDL_DestroyRenderer(renderer);
    SDL_DestroyWindow(window);
    TTF_Quit();
    SDL_Quit();
}

int isObstacle(int x, int y) {
    return maze[y / 20][x / 20] == '#';
}

int checkCollision(int x1, int y1, int x2, int y2) {
    return (abs(x1 - x2) < 20) && (abs(y1 - y2) < 20);
}

void handleInput(Pacman* pacman) {
    SDL_Event e;

    while (SDL_PollEvent(&e) != 0) {
        if (e.type == SDL_QUIT) {
            exit(0);
        } else if (e.type == SDL_KEYDOWN) {
            switch (e.key.keysym.sym) {
                case SDLK_UP:
                    pacman->direction = 1;
                    break;
                case SDLK_DOWN:
                    pacman->direction = 3;
                    break;
                case SDLK_LEFT:
                    pacman->direction = 2;
                    break;
                case SDLK_RIGHT:
                    pacman->direction = 0;
                    break;
            }
        }
    }
}

void movePacman(Pacman* pacman) {
    int nextX = pacman->x;
    int nextY = pacman->y;

    switch (pacman->direction) {
        case 0:
            nextX += PACMAN_SPEED;
            break;
        case 1:
            nextY -= PACMAN_SPEED;
            break;
        case 2:
            nextX -= PACMAN_SPEED;
            break;
        case 3:
            nextY += PACMAN_SPEED;
            break;
    }

    if (!isObstacle(nextX, nextY) && maze[nextY / 20][nextX / 20] != '#') {
        pacman->x = nextX;
        pacman->y = nextY;
    }
}

void moveGhosts(Ghost ghosts[]) {
    for (int i = 0; i < 4; ++i) {
        int targetX = ghosts[i].x;
        int targetY = ghosts[i].y;

        if (ghosts[i].x < targetX) {
            ghosts[i].vx = GHOST_SPEED;
        } else if (ghosts[i].x > targetX) {
            ghosts[i].vx = -GHOST_SPEED;
        } else {
            ghosts[i].vx = 0;
        }

        if (ghosts[i].y < targetY) {
            ghosts[i].vy = GHOST_SPEED;
        } else if (ghosts[i].y > targetY) {
            ghosts[i].vy = -GHOST_SPEED;
        } else {
            ghosts[i].vy = 0;
        }

        ghosts[i].x += ghosts[i].vx;
        ghosts[i].y += ghosts[i].vy;

        if (isObstacle(ghosts[i].x, ghosts[i].y)) {
            ghosts[i].vx = -ghosts[i].vx;
            ghosts[i].vy = -ghosts[i].vy;
        }
    }
}

void renderGame(Pacman* pacman, Ghost ghosts[]) {
    SDL_SetRenderDrawColor(renderer, 0, 0, 0, 255);
    SDL_RenderClear(renderer);

    for (int i = 0; i < ROWS; ++i) {
        for (int j = 0; j < COLS; ++j) {
            if (maze[i][j] == '#') {
                SDL_SetRenderDrawColor(renderer, 128, 128, 128, 255);
                SDL_Rect obstacleRect = {j * 20, i * 20, 12, 12};
                SDL_RenderFillRect(renderer, &obstacleRect);
            } else if (maze[i][j] == 'o') {
                SDL_SetRenderDrawColor(renderer, 255, 255, 255, 255);
                SDL_Rect pointRect = {j * 20 + 8, i * 20 + 8, 4, 4};
                SDL_RenderFillRect(renderer, &pointRect);
            }
        }
    }

    SDL_SetRenderDrawColor(renderer, 255, 255, 0, 255);
    SDL_Rect pacmanRect = {pacman->x, pacman->y, 13, 13};
    SDL_RenderFillRect(renderer, &pacmanRect);

    SDL_SetRenderDrawColor(renderer, 255, 0, 0, 255);
    for (int i = 0; i < 4; ++i) {
        SDL_Rect ghostRect = {ghosts[i].x, ghosts[i].y, 13, 13};
        SDL_RenderFillRect(renderer, &ghostRect);
    }

    // Render the score on the top left corner
    SDL_Color textColor = {255, 255, 255};
    char scoreText[50];
    snprintf(scoreText, sizeof(scoreText), "Score: %d", pacman->score);
    SDL_Surface* textSurface = TTF_RenderText_Solid(font, scoreText, textColor);
    SDL_Texture* textTexture = SDL_CreateTextureFromSurface(renderer, textSurface);
    SDL_Rect textRect = {10, 10, textSurface->w, textSurface->h};
    SDL_RenderCopy(renderer, textTexture, NULL, &textRect);

    SDL_FreeSurface(textSurface);
    SDL_DestroyTexture(textTexture);

    SDL_RenderPresent(renderer);
}

int main(int argc, char* argv[]) {
    initializeSDL();
    initializeMazePoints();  // Call the function to initialize maze points

    Pacman pacman = {SCREEN_WIDTH / 2, SCREEN_HEIGHT / 2, 3, 0, 0, 0}; // Initialize score to 0
    Ghost ghosts[4] = {{190, 190, GHOST_SPEED, GHOST_SPEED},
                      {198, 198, -GHOST_SPEED, -GHOST_SPEED},
                      {204, 204, GHOST_SPEED, -GHOST_SPEED},
                      {212, 212, -GHOST_SPEED, GHOST_SPEED}};

    SDL_Event e;

    while (1) {
        handleInput(&pacman);
        movePacman(&pacman);
        moveGhosts(ghosts);
        collectPoints(&pacman, pacman.x, pacman.y);
        renderGame(&pacman, ghosts);
        SDL_Delay(16);
    }

    closeSDL();

    return 0;
}

